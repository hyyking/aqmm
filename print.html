<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Projet CMI L3 - A Quick Marker Maker (aqmm)</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="mm/intro.html"><strong aria-hidden="true">1.</strong> Animateur de marché automatisé</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="mm/costfn.html"><strong aria-hidden="true">1.1.</strong> Mesure du risque</a></li><li class="chapter-item expanded "><a href="mm/ghpm.html"><strong aria-hidden="true">1.2.</strong> Gates Hillman Prediction Market</a></li></ol></li><li class="chapter-item expanded "><a href="async/intro.html"><strong aria-hidden="true">2.</strong> Programmation Asynchrone</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="async/futures.html"><strong aria-hidden="true">2.1.</strong> &quot;Future&quot; en language Rust</a></li><li class="chapter-item expanded "><a href="async/executor.html"><strong aria-hidden="true">2.2.</strong> Executeur</a></li></ol></li><li class="chapter-item expanded "><a href="app/intro.html"><strong aria-hidden="true">3.</strong> Structure de l'application</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app/protocol.html"><strong aria-hidden="true">3.1.</strong> Protocol</a></li><li class="chapter-item expanded "><a href="app/server.html"><strong aria-hidden="true">3.2.</strong> Serveur</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="conclusion.html">Conclusion</a></li><li class="chapter-item expanded affix "><a href="documentation.html">Documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Projet CMI L3 - A Quick Marker Maker (aqmm)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/hyyking/aqmm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Traditionnellement les marchés sont organisés en double enchères continues, ce système permet la
mise en relation des ordres aux prix désirés par les participants. Cependant ce systeme est sensible
au problème de double coincidence des besoins notamment sur les marchés peu liquides, une manière de
contourner ce problème est de passer par un intermédiaire.</p>
<p>Ce dernier peu mettre en relation les ordres de ses differents clients ou trouver des contre-parties
comme c'est le cas avec les courtiers. Les intermédiaires peuvent également se porter eux même comme
contre-partie et ainsi prendre les ordres, gérant ainsi leur propre portefeuille créant ainsi de la
liquidité sur le marché. C'est actuellement le cas sur le <em>NASDAQ</em> ou le <em>NYSE</em> avec des
spécialistes qui gèrent leur portefeuille et proposent des prix plus justes que les agents non
spécialisés. Cela permet, sur les marchés peu liquides, de réduire le tatonnement vers le prix
d'équilibre et ainsi augmenter le nombres d'échanges.</p>
<p>Cependant il existe certains marchés, appelés &quot;marchés fins&quot; (<em>thin markets</em>), ou le nombre
d'acheteurs et de vendeurs est tellement faible qu'aucun des acteurs ne pense trouver une
contrepartie et donc aucun n'entre sur le marché. C'est notamment le cas pour les marchés de
l'information qui permettent des ordres composés de plusieurs actifs simultanément, complexifiant la
mise en relation des ordres. Une solution à ce problème est d'utiliser un animateur de marché
automatisé, il s'agit d'un intermediaire contrepartiste toujours disponible à l'échange rendant le
marché entièrement liquide.</p>
<p>Ce projet présente une implémentation d'un animateur de marché automatisé. Dans une première partie
nous nous interesserons aux fondements théoriques des animateurs de marchés et à la programmation
asynchrone. Tandis que dans un second temps nous présenterons l'architecture et l'implémentation du
serveur de marché.</p>
<h1><a class="header" href="#animateur-de-marché-automatisé" id="animateur-de-marché-automatisé">Animateur de marché automatisé</a></h1>
<p>Les animateurs de marché automatisés sont des intermédiaires contrepartistes toujours disponibles à
l'échange suivant une procédure automatique de formation du prix d'achat et de vente (qui peuvent
être identiques). De cette manière, aucun vendeur ou acheteur ne doit attendre l'arrivé d'une
contrepartie éliminant une partie du problème de double coincidence des besoins. Evidemment, la
procédure automatique n'assure pas forcement un profit à l'organisateur mais assure un gain de
liquidité non-négligeable sur certain marchés.</p>
<p>Cette partie présente les fondements théoriques des animateurs de marché automatisés, avec dans un
premier temps les propriétés désirables des fonctions de coût utilisées par les animateurs. Et
enfin, nous présenterons l'expérience &quot;Gates Hillman Prediction Market&quot; menée par Abraham Othman et
Tuomas Sandholm à la Carnegie Mellon University.</p>
<h1><a class="header" href="#mesure-du-risque" id="mesure-du-risque">Mesure du Risque</a></h1>
<p>Le but des animateurs automatisés est de déterminer un prix juste en utilisant les informations des
agents sur le marché, lui meme étant non-informé.</p>
<h2><a class="header" href="#règle-de-score-de-marché" id="règle-de-score-de-marché">Règle de score de marché</a></h2>
<p>Tout d'abord nous définissons une règle de score. Considérons deux variables aléatoires \(Y: \Omega
\mapsto X\) et \(G: \Omega \mapsto Z\), ou respectivement \(Y\) et \(G\) sont les
probabilités visées par l'estimation et les probabilité générés par l'estimation. Une fonction de
score est définit par \(S: Y \times G \mapsto \mathbb{R}\). Autrement dit il s'agit d'une fonction
mathématique associant à un ensemble de probabilités estimés un nombre que l'on peut interpreter
comme la &quot;justesse&quot; de l'approximation. On considère que le point qui minimise la fonction de score
est celui ou les probabilités se rapproche le de l'évènement réel.</p>
<p>Avec une règle de score, les agent rapportent leurs probabilités pour chaque évènement et recoivent
un paiement selon chaque réalisation. Une règle de score de marché est une règle de score ou tout le
monde peut changer ses choix à chaque instant et recevoir un paiement dependant de son estimation
finale. Le cout induit par la règle de score de marché est celui de la dernière estimation
rapportée, comparée à la première. Dans <a href="https://mason.gmu.edu/%7Erhanson/mktscore.pdf">Hanson (2002)</a>
l'auteur montre que toute fonction de score rapportant des probabilités honnètes peut être utilisé
comme règle de score de marché.</p>
<h2><a class="header" href="#animateurs-de-marché-à-fonction-de-score" id="animateurs-de-marché-à-fonction-de-score">Animateurs de marché à fonction de score</a></h2>
<p>Nous décrivons désormais le déroulement des échanges avec un animateur de marché automatique à
fonction de score. Ce dernier commence avec un état initiale (généralement \(\vec{0}\)). Les
agents interagissent avec l'animateur en modifiant son état interne de \(x\) à \(x'\) pour un
prix de \(C(x') - C(x)\). Par exemple pour des évènement indépendants et complémentaires
\(\omega_1\) et \(\omega_2\) et un état initial de \(\{0, 0\}\) si un agent souhaite acheter
deux titres associés à \(\omega_2\) il devra d'affranchir de \(C(\{0, 0 + 2\}) - C(\{0,
0\})\). Ainsi on peut qualifier le prix d'un actif comme le gradient de la fonction de score par
rapport à cet actif.</p>
<h2><a class="header" href="#propriétés-désirables-des-fonctions-de-score-de-marché" id="propriétés-désirables-des-fonctions-de-score-de-marché">Propriétés désirables des fonctions de score de marché</a></h2>
<p>Il existe un ensemble de propriété désirables pour ces règle de score, en effet on aimerait limiter
la perte d'un animateur de marché et proposer des prix cohérents. On liste cinq propriétés
désirables:</p>
<h4><a class="header" href="#1-monotonie" id="1-monotonie">1. Monotonie</a></h4>
<p>\[\forall x,y \space s.t. \space x_i \le y_i, \space C(x) \le C(y)\]</p>
<p>Interprétation: le prix marginal d'un ordre ne décroit jamais, empechant d'acheter des combinaisons
à prix 0 en faisant des gains.</p>
<h4><a class="header" href="#2-convexité" id="2-convexité">2. Convexité</a></h4>
<p>\[\forall x,y \space and \space \lambda \in [0, 1] \] \[C(\lambda x + (1-\lambda) y) \le \lambda
C(x) + (1 - \lambda) C(y) \]</p>
<p>Interprétation: une annonce diversifié donne un score plus faible que deux annonces séparés. Ainsi
cela incite à la diversification des portfeuilles.</p>
<h4><a class="header" href="#3-perte-borné" id="3-perte-borné">3. Perte borné</a></h4>
<p>\[\sup_x[\max_i(x_i) - C(x)] \lt \infty \]</p>
<p>Interprétation: permet d'assurer une perte borné peu importe les actions des agents et les états
réalisés.</p>
<h4><a class="header" href="#4-invariance-à-la-translation" id="4-invariance-à-la-translation">4. Invariance à la translation</a></h4>
<p>\[\forall \vec{x},\alpha \] \[C(x + \vec{1} \alpha) = C(x) + \alpha \]</p>
<p>Interprétation: Si on pari \(\alpha\) unités sur tous les états on paie \(\alpha\) unités.</p>
<h4><a class="header" href="#5-homogénéité-positive" id="5-homogénéité-positive">5. Homogénéité positive</a></h4>
<p>\[\forall \vec{x},\gamma \gt 0\] \[C(x \gamma) = C(x) \gamma \]</p>
<p>Interprétation: Si on double son pari on paie double.</p>
<h2><a class="header" href="#impossibilité-du-résultat" id="impossibilité-du-résultat">Impossibilité du résultat</a></h2>
<p>D'après ces propriétés il est possible de prouver qu'il n'existe qu'une fonction qui les statisfait
toutes et il s'agit de la fonction de score max:</p>
<p>\[ C(x) = \max_{x_i} x\]</p>
<p>Cependant cette fonction implique qu'il est gratuit de déplacer l'animateur de marché d'un état
\(\{1, 0\}\) à l'état \(\{1, 1\}\). En pratique il s'agit d'une mauvaise mesure du risque et
ainsi il est impossible de satisfaire toutes ces propriétés.</p>
<p>Pour diminuer la restriction on enlève généralement soit l'homogénéité positive ou l'invariance à la
translation. La fonction présentée dans la partie suivante satisfait les 4 premières propritétés.</p>
<h2><a class="header" href="#règle-de-score-de-marché-logarithmique-logarithmic-market-scoring-rule" id="règle-de-score-de-marché-logarithmique-logarithmic-market-scoring-rule">Règle de score de marché logarithmique (Logarithmic Market Scoring Rule)</a></h2>
<p>Définition:</p>
<p>\[ C(x) = b\log{\sum_i{\exp(x_i/b)}} \]</p>
<p>\[ p_i(x) = {\exp(q_i/b) \over {\sum_k \exp(q_k/b)}} \]</p>
<p>La règle de score logarithmique a été introduite par Hanson elle est lié à un paramètre \(b\) qui
influe sur la liquidité (illustration ci- dessous). Elle à l'avantage de garantire l'indépendance
des effets liés aux actions des individus. En effet, lorsqu'un individu fait un pari sur un
évènement A lié à un évènement B alors l'estimation de probabilité lié à l'autre évènement n'est pas
modifié. Cette fonction est particulièrement utile pour les marchés combinatoires.</p>
<p>Le paramètre \(b\) influe négativement sur le gradient, si on compare graphiquement un \(b=0.2\)
et \(b=1000\) on observe que sur le premier graphique le score le plus haut est atteint beaucoup
plus rapidement avec une &quot;valée&quot; des paris diversifiés ou le score monte plus lentement. Sur le
second graphique le plan est quasiment plat est les valeurs les plus hautes sont atteinte seulement
lors des plus grandes combinaisions autour (10, 10). Ainsi le paramètre \(b\) influe sur la
liquidité car un \(b\) faible permet d'inciter un report équitable des probabilités avec un score
plus elevé pour les ajouts unilatéraux réduisant ainsi le nombre potentiels de personnes sur le
marché.</p>
<p><img src="mm/../img/lsmr_b0.2.png" alt="b0.2" /> <img src="mm/../img/lsmr_b1000.png" alt="b0.2" /></p>
<h1><a class="header" href="#gates-hillman-prediction-market" id="gates-hillman-prediction-market">Gates Hillman Prediction Market</a></h1>
<p>L'expérience du Gates Hillman Prediction Market (GHPM) est un exemple de marché de l'information ou
les individus échangent sur les probabilités d'un évènement, en l'occurence l'ouverture du centre
Gates-Hillman à l'université Carnegie-Mellon. Menée par Abraham Othman et Tuomas Sandholm,
l'expérience aura duré un an avec 169 individus actifs pour 210 inscrits.</p>
<h2><a class="header" href="#mise-en-place" id="mise-en-place">Mise en place</a></h2>
<p>Un problème lié à la mise en place de marchés de l'information est la définition exacte des
évènements de tel sorte que l'on sache si ils se sont réalisés. En effet par le mot ouverture on
pourrait penser à la fin des travaux comme à l'enménagement complet du personnel. La définition vers
laquelle s'est tendu l'experience est &quot;lorsque 50% de l'espace occupable aura reçu son permis
d'exploitation&quot; qui est un élément aisément vérifiable administrativement.</p>
<p>Afin qu'assez d'invidus participent au marché les organisateurs ont recolté un prix pour le tirage
au sort final pondéré par le nombre d'actifs de chaque participant. Deplus, les participants
recevaient 20 tickets gratuits lors de l'inscription et 2 tickets par semaine s'ils étaient actifs.</p>
<h2><a class="header" href="#fonctionnement" id="fonctionnement">Fonctionnement</a></h2>
<p>Le GHPM utilisait une fonction de score de marché logarithmique avec un paramètre \(b=32\). Afin
de pouvoir parier sur une date, il a fallu trouver un manière en trois temps de faire l'échange. En
effet, en premier les paris étaient eux formulés sur un interval de temps plutot que sur des jours
uniques car les individus ont du mal à raisonner sur des probabibilités faibles (Ali, 1977). Dans
cette même requète les individus indiquaient un montant à parier. Ensuite, l'animateur de marché
proposait deux contrats &quot;pour&quot; et &quot;contre&quot; indiquant le montant gagné et la probabilité associée.
Enfin l'utilisateur choisissait un contrat et recevait le montant de ticket désignait si au cours de
la période l'évènement selectionné s'était réalisé.</p>
<p><img src="mm/../img/ghpm_bet.png" alt="ghpm image" /></p>
<p>^ Capture d'écran de l'interface.</p>
<p>Les montants gagné \( \pi_j\) pour une période \([i, j]\) étaient calculés selon les équations
qui satisfont l'invariance à la translation pour le pari \(r\):</p>
<ul>
<li>Les paris &quot;pour&quot;: \[ C(q_1, ..., q_i + \pi_j, ... + \pi_j, q_j + \pi_j, ...) = C(q) + r\]</li>
<li>Les paris &quot;contre&quot;: \[ C(q_1 + \pi_j, ... + \pi_j, q_i, ... , q_j, ...+ \pi_j) = C(q) + r\]</li>
</ul>
<p>La résolution des équations était faite en utilisant la
<a href="https://en.wikipedia.org/wiki/Newton%27s_method">méthode de newton</a> et donc approximée.</p>
<h2><a class="header" href="#résultats" id="résultats">Résultats</a></h2>
<p>Dans cette section nous présentons les problèmes revélés par l'experience et les stratégies qui s'en
sont suivis.</p>
<h3><a class="header" href="#pics-de-prix" id="pics-de-prix">Pics de prix</a></h3>
<p>Un des problèmes principaux qui est apparu lors de l'experience du GHPM est l'apparition de pics de
prix, en effet on pouvait observer une grande difference de prix sur deux jours différents comme le
montre le graphique ci-dessous tiré du papier originel:</p>
<p><img src="mm/../img/spikes.png" alt="spikes image" /></p>
<p>Ce problème trouve un fondement théorique, une règle de score ne produisant pas de pics doit
satisfaire la contrainte:</p>
<p>\[ \lim_{p_i \to 0} {\delta q \over \delta q^2_i} p_i(q_i, q_{-i}) \le 0 \]</p>
<p>Qui indique que le prix doit être concave par rapport aux quantités. Le papier présente une preuve
expliquant qu'une règle de score libre (opposé à une règle de score borné manuellement) ne peut pas
satisfaire cette contrainte. L'inconvénient des règle de score borné manuellement viendrait d'une
implémentation plus complexe informatiquement et donc moins efficace.</p>
<p>Lors de l'expérience cet effet à eu un impact sur la stratégie des agents. Les chercheurs ont mené
des interviews avec certains utilisateur, lors d'une de ces interviews une personne admet avoir
suivis ces pics afin de parier contre car selon lui ils venait d'une mauvaise estimation de la part
des autres agents qui avait parié sur des périodes très courtes, de cette manière une fois les
périodes surestimés passés il gagnait ses paris.</p>
<h3><a class="header" href="#insensibilité-à-la-liquidité" id="insensibilité-à-la-liquidité">Insensibilité à la liquidité</a></h3>
<p>En utilisant la fontion LMSR, l'animateur de marché satisfait l'invariance à la translation et ainsi
produit les mêmes variation de prix peut importe la quantité d'actifs présents sur le marché, ce qui
est contre-intuitif lorsque l'on pense aux marchés en pratique. Cette proprieté permet d'eviter les
opportunités d'arbitrage mais accentue les effets marginaux sur des marchés &quot;profonds&quot;, avec un
grand nombre d'actifs disponibles.</p>
<p>Cet effet à eu un impact négatif sur l'experience, notamment sur la fin, car les agents avait peur
de faire des mouvements plus gros qui auraient pu faire basculer la valeur de leur portefeuille.
D'après une interview, vers la fin de l'expérience une des personnes les mieux placés a essayé de
limiter ses placement afin de justement eviter de former des pics liés à cet insensibilité à la
liquidité.</p>
<p>Une solution à ce problème est exploré dans le papier <em>A Practical Liquidity-Sensitive Automated
Market Maker</em> par A. Othman et D. Pennock.</p>
<h2><a class="header" href="#estimation" id="estimation">Estimation</a></h2>
<p>Les estimations du GHPM sont présentés par ce graphique tiré du papier.</p>
<p><img src="mm/../img/ghpm_estimate.png" alt="Estimation du ghpm" /></p>
<p>Une observe une convergence des estimations plus la veritable date approchait, la convergence touche
tous les pourcentiles. A partir de Février, lors d'une seconde annonce officielle la période
d'ouverture était plus ou moins connu et on observe que des petites variations à partir de ce moment
la alors que les annonces suivantes en Juillet on amélioré la prédiction jusqu'à la date d'ouverture
alors que la tendance prévoyait une période un peu plus longue.</p>
<p>Le graphique suivant présente la masse de personnes ayant eu un iterval correct en fonction des mois
où le marché était ouvert.</p>
<p><img src="mm/../img/ghpm_pb.png" alt="Pb ghpm" /></p>
<h1><a class="header" href="#programmation-asynchrone" id="programmation-asynchrone">Programmation Asynchrone</a></h1>
<p>La programmation asynchrone opposée à la programmation linéaire, désigne l'indépendance de l'ordre
des événements dans l'éxecution du programme.</p>
<p>La nature de ces événements est généralement lié à l'attente de la fin d'une action d'un autre
processus (pour les temps de calcul longs) ou d'un autre ordinateur si les deux sont connectés.
Cette approche permet, notamment, de gérer une multitude de connections sans lancer de processus
indépendants. En effet, toutes les connections ne sont pas actives simultanément. Par exemple, pour
construire un marché tous les clients connectés n'emettent pas des ordres continuellement, certains
sont plus actifs que d'autres. Plutot que d'assumer des fréquences d'ordre et vérifier par order de
priorité les connections, on utilise de la programmation asynchrone afin que dès que de
l'information peut être récupéré les taches associées soient executés.</p>
<p>Dans le cadre du projet nous allons voir le modèle de programmation asynchrone en language
<a href="https://www.rust-lang.org/"><strong>Rust</strong></a>.</p>
<h1><a class="header" href="#future-et-stream-en-language-rust" id="future-et-stream-en-language-rust">Future et Stream en language Rust</a></h1>
<p>Le language Rust n'est pas un language orienté objet comme les autres, en effet il n'existe pas
d'objets à proprement parler. Cependant, les structures peuvent avoir des methodes associés uniques
et d'autres apportés par un <em>trait</em> (penser trait de charactère <code>content -&gt; sourire()</code>). Ainsi pour
définir les calculs asynchrones le language fournit le <em>trait</em> <code>std::future::Future</code> et pour les
itérateurs asynchrones <code>futures::stream::Stream</code> qui se trouve dans la librarie
<a href="https://docs.rs/futures/0.3.5/futures/index.html">futures</a> maintenu par les developpeurs du
language en attendant d'être stabilisé.</p>
<p>Dans cette partie nous verrons comment est définit le <em>trait</em> <code>std::future::Future</code>, en quoi il
définit un calcul asynchrone et comment il est utilisé en pratique. Enfin nous étendrons ça aux
itérateurs asynchrones avec le <em>trait</em> <code>futures::stream::Stream</code>.</p>
<h2><a class="header" href="#stdfuturefuture" id="stdfuturefuture"><code>std::future::Future</code></a></h2>
<h3><a class="header" href="#définition" id="définition">Définition</a></h3>
<p>Le <em>trait</em> est définit de la façon suivante.</p>
<pre><code class="language-rust ignore">pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre>
<p>Lorsque nous décomposons nous voyons qu'il y a un type associé <code>type Output;</code> qui correspond au type
de l'élément retourné par le future. Concernant la méthode, elle retourne <code>Poll&lt;T&gt;</code> un <em>enum</em>, avec
un paramètre générique <code>T</code>, pouvant prendre deux formes:</p>
<pre><code class="language-rust ignore">pub enum Poll&lt;T&gt; {
	Ready(T),
	Pending
}
</code></pre>
<p>Ainsi, lorsque que la fonction retourne <code>Poll::Ready(10)</code> on dit que le future est terminé car il a
produit une valeur. Tandis que lorsque <code>Poll::Pending</code> est renvoyé cela veut dire qu'il n'est pas
encore terminé et il doit être reveillé par un évènement qui indique qu'il va peut-être renvoyer
<code>Poll::Ready(_)</code>. Pour que le future soit reveillé il reçoit une référence (<code>&amp;mut</code>) à un <code>Context</code>,
dont il peut recuperer le <code>Waker</code>, structure qui permet de reveiller la tache associé, et le stocke
quelque part pour qu'un autre processus puisse le reveiller.</p>
<p>PS: Nous ne nous attarderons pas sur <code>Pin&lt;&amp;mut Self&gt;</code> qui assure seulement que le future n'est pas
remplacé pendant un appel à <code>poll</code>.</p>
<h3><a class="header" href="#calcul" id="calcul">Calcul</a></h3>
<p>En général les futures utilisés en rust sont issues de la combinaison de plusieurs futures. Avant
novembre 2019 et la sortie de la version 1.39.0 les combinaison étaient effectués avec des
structures dites combinatoires.</p>
<h4><a class="header" href="#combinatoire-pre-139" id="combinatoire-pre-139">Combinatoire pre 1.39</a></h4>
<h5><a class="header" href="#composition-sequentielle" id="composition-sequentielle">Composition sequentielle:</a></h5>
<ul>
<li><em>Ex</em>: <code>f.and_then(|output_future_precedent| nouveau_future(output_future_precedent))</code></li>
<li><em>Implication</em>: lorsque future <code>f</code> est executé jusqu'au bout, un nouveau future est construit du
resultat du précédent</li>
</ul>
<h5><a class="header" href="#changement-de-type" id="changement-de-type">Changement de type:</a></h5>
<ul>
<li><em>Ex</em>: <code>f.map(|output_future_precedent| nouveau_type(output_future_precedent))</code></li>
<li><em>Implication</em>: le type <code>Output</code> du future <code>f</code> est passé dans une fonction lui donnant un nouveau
type (modifiant ainsi sa valeur à la fin de l'éxécution).</li>
</ul>
<h5><a class="header" href="#jointure" id="jointure">Jointure:</a></h5>
<ul>
<li><em>Ex</em>: <code>f.join(g)</code></li>
<li><em>Implication</em>: les futures <code>f</code> et <code>g</code> sont éxécuté parallement et le nouveau future se termine
lorsque les deux sont terminés.</li>
</ul>
<h5><a class="header" href="#selection" id="selection">Selection:</a></h5>
<ul>
<li><em>Ex</em>: <code>f.select(g)</code></li>
<li><em>Implication</em>: les futures <code>f</code> et <code>g</code> sont executé parallement et le nouveau future se termine
lorsqu'un des deux est terminé.</li>
</ul>
<h4><a class="header" href="#mise-à-jour-139" id="mise-à-jour-139">Mise à jour 1.39</a></h4>
<p>Depuis la mise à jour 1.39.0 la syntaxe <code>async/await</code> à été stabilisé permettant d'utiliser les
futures comme du code classique. Pour recuperer le resultat d'un future il faut symplement <code>await</code>,
ce qui execute le future, dans une fonction <code>async</code>hrone, qui indique elle meme etre un future (nous
reviendrons sur la récupération du résultat d'un future dans la partie suivante).</p>
<p>Ex:</p>
<pre><code class="language-rust ignore">// Ici le type de retour est implicitement `impl Future&lt;Output = String&gt;`
// Soit une &quot;structure qui est un future avec comme resultat un pointeur de texte&quot;
async fn demo() -&gt; String {
	// création et attente du resultat du future
	let future1: u64 = Future1::new().await;
	assert!(future1 == 10);

	// création du future sans attendre le resultat
	let future2 = Future2::new();

	// attente du résultat et changement de type + retour implicite de la fonction
	String::from(future2.await)
}
</code></pre>
<p>Cette syntaxe rend la combinatoire obselète car on travaille toujours avec les valeurs directement,
permettant ainsi de les combiner ou de modifier leur type de manière plus aisé.</p>
<h2><a class="header" href="#futuresstreamstream" id="futuresstreamstream"><code>futures::stream::Stream</code></a></h2>
<p>Si un future est l'équivalent d'une promesse de valeur dans le temps, un <code>Stream</code> est lui
l'équivalent d'une succession de valeur qui arrivent à la suite. Pour comprendre ce principe il
convient de d'abord regarder le principe d'un itérateur pour l'étendre aux stream et en présenter
les applications.</p>
<h3><a class="header" href="#définition-1" id="définition-1">Définition</a></h3>
<p>Tout d'abord définisson les itérateurs, qui sont des structures permettant de traverser un
collection comme par exemple une liste. Les itérateurs produisent des valeurs consommés par une
boucle. Les valeurs peuvent venir d'une liste, d'un calcul (suite de fibonacci par exemple), ou bien
d'une autre operation comme l'attente d'un message d'un autre processus. La différence première avec
un Stream est que l'itérateur bloque le processus à chacune de ses valeurs, le stream à l'instare
des futures attend d'être reveillé s'il est capable de produire une valeur. S'en suit la définition
suivante.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait Stream {
    type Item;
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Tout comme les futures il y a un resultat (<code>Item</code>), un <code>Poll</code> et une référence à un <code>Context</code>.
Cependant pour determiner la fin d'un stream le language utilise un autre <em>enum</em> commun
l'<code>Option&lt;T&gt;</code> qui prend (comme <code>Poll&lt;T&gt;</code>) une variante avec un objet (<code>Option::Some(T)</code>) et une sans
(<code>Option::None</code>). Ainsi on peu faire une disjonction de cas:</p>
<ul>
<li><code>Poll::Ready(Some(Item))</code> =&gt; la valeur est prête à être consommée.</li>
<li><code>Poll::Ready(None)</code> =&gt; le stream ne produira plus de valeurs.</li>
<li><code>Poll::Pending</code> =&gt; la prochaine valeur n'est pas encore prête un processus reveillera ce stream
lorsque ce sera le cas.</li>
</ul>
<h3><a class="header" href="#calcul-1" id="calcul-1">Calcul</a></h3>
<p>Les streams possèdent également des combinatoires qui se trouve dans le <em>trait</em>
<a href="https://docs.rs/futures/0.3.5/futures/stream/trait.StreamExt.html"><code>futures::stream::StreamExt</code></a>.
Les principales sont:</p>
<h5><a class="header" href="#next" id="next">Next</a></h5>
<ul>
<li><em>Ex</em>: <code>stream.next()</code></li>
<li><em>Implication</em>: Produit un future qui se résout lorsque la prochaine valeur arrive ou le stream est
terminé.</li>
</ul>
<h5><a class="header" href="#map" id="map">Map</a></h5>
<ul>
<li><em>Ex</em>: <code>stream.map(|val| { calcul(val) })</code></li>
<li><em>Implication</em>: Produit un stream ou tous les objets de type <code>Item</code> sont modifiés en un autre type</li>
</ul>
<h5><a class="header" href="#for-each" id="for-each">For Each</a></h5>
<ul>
<li><em>Ex</em>: <code>stream.for_each(|val| { calcul(val) })</code></li>
<li><em>Implication</em>: Produit un future qui se résout lorsque toute les valeurs sont arrivées et ont été
traitées.</li>
</ul>
<h5><a class="header" href="#filter" id="filter">Filter</a></h5>
<ul>
<li><em>Ex</em>: <code>stream.filter(|ref val| { val % 2 == 0 })</code></li>
<li><em>Implication</em>: Produit un stream dont les éléments ou le calcul renvoit <code>false</code> ne sont pas
retourné.</li>
</ul>
<h1><a class="header" href="#executeur" id="executeur">Executeur</a></h1>
<p>Cette partie est l'extention de la partie précedente sur les <code>std::future::Future</code>, nous y
expliquons le principe d'un executeur de future.</p>
<h2><a class="header" href="#execution-dun-future" id="execution-dun-future">Execution d'un future</a></h2>
<p>Comme vu precedement pour executer un future il faut un <code>Waker</code> permettant de se réveiller la tache.
Que veut dire réveiller une tache? Dans le cadre des futures nous avons vu qu'il s'agit de refaire
appel à la méthode <code>poll</code>. Cette tache est associé au concept de &quot;runtime&quot;, ou unité d'éxécution,
dans d'autres languages. En effet, en python ou en go le language fait tourner un processus qui se
charge d'executer les calculs asynchrones, ce processus est appelé &quot;runtime&quot;. Le language rust
essayant de se maintenir à un bas niveau d'abstraction ne fournit pas un runtime, ainsi il s'agit de
la tache du programmeur d'en utiliser/programmer un. Des exemples de runtimes rust sont
<a href="https://docs.rs/tokio">tokio</a> et <a href="https://docs.rs/async-std">async-std</a>.</p>
<h2><a class="header" href="#bloquer-sur-un-future" id="bloquer-sur-un-future">Bloquer sur un future</a></h2>
<p>Comme il n'y a pas de runtime en language rust il faut la capacité de bloquer sur un futur à
l'origine des autres. Pour se faire un peu utiliser les capacité du système d'opération pour bloquer
les processus et ainsi ne pas créer un boucle qui attend que le future se termine avec un context
finalement inutile. Un <a href="https://stjepang.github.io/2020/01/25/build-your-own-block-on.html">exemple</a>
minimaliste d'une telle fonction est le suivant:</p>
<pre><code class="language-rust ignore">fn block_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
    pin_utils::pin_mut!(future); // pour avoir un Pin&lt;&amp;mut Self&gt; pour le future

    let parker = crossbeam::Parker::new(); // permet de mettre en pause le processus
    let unparker = parker.unparker().clone();
    let waker = async_task::waker_fn(move || unparker.unpark()); // Création du Waker qui réveil le processus

    let cx = &amp;mut Context::from_waker(&amp;waker); // création du contexte à partir du Waker
    loop {
        match future.as_mut().poll(cx) {
            Poll::Ready(output) =&gt; return output,
            Poll::Pending =&gt; parker.park(), // mise en pause du processus si la valeur n'est pas prète en attendant le reveil
        }
    }
}
</code></pre>
<p>Cette exemple utilise deux librairies (<code>crossbeam</code> et <code>async-task</code>) mais montre bien le processus
d'execution. Tant que le future n'est pas terminé on appel <code>Future::poll</code>, s'il ne se termine pas on
parque le processus sur le système d'opération et on attend d'etre reveillé par le waker qui va le
remettre en execution.</p>
<h2><a class="header" href="#execution-asynchrone" id="execution-asynchrone">Execution asynchrone</a></h2>
<p>Sur l'exemple si dessus nous avons trouvé un moyen d'attendre le resultat d'un future sans éxécuter
la boucle constamment (en parquant le processus). Cependant parfois on souhaite qu'un future soit
executé sans se soucier du resultat et ce de manière asynchrone. La plupart des runtime ont une
commande pour <code>spawn</code> un future qui sera éxécuté par un ensemble de processus sans bloquer sur une
tache en particulier. Souvent les runtimes utilisent un systeme de vol de taches pour maintenir la
bonne répartition de ces dernières à travers les differents processus.</p>
<p>En étendant sur l'exemple précedent:</p>
<pre><pre class="playground"><code class="language-rust">// Liste des taches
static QUEUE: Vec&lt;Task&gt; = Vec::new();

// pour lancer une tache on l'ajoute à la file
fn spawn&lt;F: Future&gt;(future: F) {
	// A chaque reveil on ajoute le future à la file d'attente
    let (task, _) = async_task::spawn(future, |f| QUEUE.push(f), ());
	task.schedule()
}

fn block_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
	/* ... */
    loop {
		// On execute les taches reveillés ici
		for task in QUEUE {
			task.run()
		}
        match future.as_mut().poll(cx) {
			/* ... */
        }
    }
}

fn main() {
	block_on(async {
		// stream de connections
		for connection in Listener::new() {
			spawn(async {
				// imprimer le prochain message
				println!(connection.next().await)
			});
		}
	})
}
</code></pre></pre>
<p>De cette manière plusieurs taches peuvent être executés en parallèle sans avoir un processus associé
pour chacune.</p>
<h1><a class="header" href="#structure-de-lapplication" id="structure-de-lapplication">Structure de l'application</a></h1>
<p>Pour ce projet j'ai décidé de construire un serveur et des clients afin de faire une simulation d'un
marché utilisant un animateur de marché automatique. Dans cette partie j'expliquerais le protocol de
communication utilisé entre le serveur et les clients, enfin je présenterais en détail la structure
du serveur.</p>
<h1><a class="header" href="#protocol" id="protocol">Protocol</a></h1>
<p>La communication entre le serveur et les client se fait par message rpc encodé en protobuf, dans
cette partie nous verrons les détails.</p>
<h2><a class="header" href="#remote-procedure-call-rpc" id="remote-procedure-call-rpc">Remote Procedure Call (RPC)</a></h2>
<p>Le RPC est un protocole réseau permettant l'éxécution de taches sur un serveur depuis un client.
Cette solution semble être bonne pour construire un marché ou les ordres sont demandé par le client
et effectué par le serveur.</p>
<p>Le client envois un premier une requête et bloque en attendant une réponse. Dans le cas de ce
serveur le client à le choix entre 3 requêtes:</p>
<ol>
<li>Requête d'identification: permet au serveur de charger la session ou d'en créer une si elle
n'existe pas, la réponse contient l'identifiant de la session.</li>
<li>Requête de la liste des titres: le serveur renvoie la liste des titres disponible avec une courte
description de chacuns.</li>
<li>Requête d'ordres: le serveur execute et renvois le résultat des ordres.</li>
</ol>
<h2><a class="header" href="#protobuf" id="protobuf">Protobuf</a></h2>
<p>Protocol Buffers est un format de sérialisation et de description d'interface développé par Google.
Originellement conçut pour un nombre limité de languages nous utiliserons une implementation
open-source pour Rust appelé <a href="https://docs.rs/prost/0.6.1/prost/">prost!</a>.</p>
<h3><a class="header" href="#language-de-description-dinterface" id="language-de-description-dinterface">Language de description d'interface</a></h3>
<p>Les language de description d'interface permettent de définir des composants de logiciel dans un
language neutre de l'implementation de ce dernier. C'est à dire que si un fichier de description est
partagé entre un serveur et un client, ils pourront être implémenté dans différents languages de
programmation car ils auront la description des éléments pour désérialiser les données.</p>
<p>Ex:</p>
<p>Le protobuf</p>
<pre><code class="language-protobuf">message Ordre {
	uint64 qt = 1;
	double prix = 2;
}
</code></pre>
<p>devient en rust:</p>
<pre><code class="language-rust ignore">pub struct Ordre {
	qt: u64,
	prix: f64,
}
</code></pre>
<p>et en java:</p>
<pre><code class="language-java ignore">public class Ordre {
  long qt;
  double prix;
}
</code></pre>
<h3><a class="header" href="#sérialisationdésérialisation" id="sérialisationdésérialisation">Sérialisation/Désérialisation</a></h3>
<p>La désérialisation est le fait de réduire une structure de donnée d'un programme en un ensemble
cohérent en binaire. La sérialisation, qui est l'inverse de la désérialisation, est le fait de créer
un structure de donnée depuis un ensemble cohérent d'information binaire.</p>
<p>Couplé ensemble ils permettent de stocker des structures de données dans des bases de données ou
d'envoyer ces premières à travers des réseaux. En effet, si un client et un serveur possèdent la
même structure ils peuvent s'échanger des information structuré facilement en restructurant les
informations de l'autre.</p>
<h2><a class="header" href="#transmission" id="transmission">Transmission</a></h2>
<p>Les clients se connectent via TCP (Transmission Control Protocol) pour emmettre les message RPC.</p>
<p>Concernant les information de quantité sont relayé via un système de multicasting en UDP (User
Datagram Protocol), c'est à dire un système ou le serveur envoie de la donnée à une adresse et les
clients qui le souhaite récupèrent la donnée sans que le serveur ai à entretenir une connection ou
compter les personnes lisant les quantités. Auquel cas Le message protobuf envoyé est <code>Broadcast</code>.</p>
<h2><a class="header" href="#protocol-entier" id="protocol-entier">Protocol entier</a></h2>
<pre><code class="language-proto">syntax = &quot;proto3&quot;;

package protocol;

// Buy/Sell tag for an order
enum Kind {
	Buy = 0;
	Sell = 1;
}

// Security
//	security_id: id to use if you want to place orders
//	description: description of the security
message Security {
	uint64 security_id = 1;
	string description = 2;
}

// SecurityBroadcast
//	security: affected security
//	quantity: current quantity
message SecurityBroadcast {
	Security security =1;
	double quantity = 2;
}
// Broadcast
//	broadcast: all updates on securities
message Broadcast {
	repeated SecurityBroadcast broadcast = 1;
}

// Order
//	security_id: targeted security
//	kind: direction of the order
//	amount: amount bought/sold
message Order {
	uint64 security_id = 1;
	Kind kind = 2;	
	double amount = 3;
}

// Result of an order
//	security_id: targeted security
//	kind: direction of all orders for a security
message OrderResult {
	uint64 security_id = 1;
	Kind kind = 2;
	double balance = 3;
}

// Request to get the list of securities
message RequestSecurities {}
// Response with all the availabe securities
message ResponseSecurities {
	repeated Security securities = 1;
}

// Request to get authenticated to the server
message RequestAuthenticate {}
// Response to authentication request with the uuid
message ResponseAuthenticate {
	bytes uuid = 1;
}

// Request to place orders
message RequestOrder {
	repeated Order orders = 1;
}
// All the order results
message ResponseOrder {
	repeated OrderResult orders = 1;
}

// Unified response type
message Response {
	uint32 id = 1;
	oneof response {
		ResponseAuthenticate auth = 2;
		ResponseOrder order = 3;
		ResponseSecurities security = 4;
	}
}

// Unified request type (uuid can be empty before authentication)
message Request {
	uint32 id = 1;
	bytes uuid = 2;
	oneof request {
		RequestAuthenticate auth = 3;
		RequestOrder order = 4;
		RequestSecurities security = 5;
	}
}
</code></pre>
<h1><a class="header" href="#serveur" id="serveur">Serveur</a></h1>
<p>Dans cette partie nous verrons a construction du serveur, ce dernier est répartit en plusieurs
modules le premier étant celui des ressources Input/Output c'est à dire concernant les abstractions
liés aux notifications système. Un deuxième module connexe au premier fait la liaison entre les
entrée de notification systeme et les connections TCP permettant à ces dernières d'être entièrement
asynchrones. Un dernier est lié au marché avec la liste des titres et les modules d'éxécution
d'ordre.</p>
<p>Structure des éléments de l'application (dossiers et fichiers non pertinents omis):</p>
<pre><code>.
├── build.rs			-&gt; script de compilation, génère le code protobuf
├── Cargo.toml			-&gt; fichier de spécification du projet
├── src
│   ├── lib.rs
│   ├── ...
│   ├── net
│   │   ├── mod.rs
│   │   ├── codec.rs
│   │   └── tcp.rs
│   ├── market
│   │   ├── securities.rs
│   │   ├── core.rs
│   │   ├── mod.rs
│   │   ├── pool.rs
│   │   └── router.rs
│   ├── io
│   │   ├── mod.rs
│   │   ├── registration.rs
│   │   └── driver
│   │       ├── context.rs
│   │       └── mod.rs
│   ├── server.rs
│   └── bin			-&gt; binaires éxécutables
├── proto
│   └── aqmm.proto		-&gt; protocol en protobuf
└── ...
</code></pre>
<h2><a class="header" href="#exécuteur-et-io" id="exécuteur-et-io">Exécuteur et I/O</a></h2>
<p>La structure du serveur (dans le fichier <code>src/server.rs</code>) est composé d'un &quot;driver&quot; pour les
ressources I/O liés aux connections arrivant. Le but du serveur est d'écouter les connections
arrivantes et pour chaque connection d'éxécuter un client qui prend la forme d'un future. A chaque
client est associé une connection ainsi qu'une session. Afin de determiner quels clients ont une
action de prête le serveur utilise la librairie <a href="https://docs.rs/mio"><code>mio</code></a> qui permet d'associer
des ressources I/O et d'emettre des notifications sur les connections ayant du travail. Les
évènements sont ensuite transferé à des entrées contenant les <code>std::task::Waker</code> des streams de
message des clients ces messages sont ensuite décodés et une réponse est envoyé suviant le protocole
décrit dans la partie précédente.</p>
<h2><a class="header" href="#réseau" id="réseau">Réseau</a></h2>
<p>Le module <code>src/net</code> contient tous les éléments nécéssaire au maintient et à l'utilisation des
connections.</p>
<h3><a class="header" href="#stream-tcp-asynchrone" id="stream-tcp-asynchrone">Stream Tcp Asynchrone</a></h3>
<p>Le driver de ressources I/O permet de savoir quand une connection est en mesure d'être écrite/lu. De
cette manière le driver peut reveiller les <code>Waker</code> associés. Il manque donc deux <em>trait</em> comme
<code>std::future::Future</code> mais pour les actions de lecture et d'ecriture d'un flux de donnée. Le
language expose les <em>traits</em> synchrone <code>std::io::Read</code> et <code>std::io::Write</code>. La libraire <code>futures</code>
définit de la même facon <code>futures::io::AsyncRead</code> et <code>futures::io::AsyncWrite</code>. Ainsi avec le driver
I/O nous pouvons construire une abstraction par dessus un TcpStream synchrone qui implémente
<code>AsyncRead + AsyncWrite</code></p>
<h3><a class="header" href="#codec" id="codec">Codec</a></h3>
<p>Les codecs sont des structures construites sur les <em>traits</em> <code>tokio_util::codec::Encoder</code> et
<code>tokio_util::codec::Decoder</code> trouvé dans la librairie <a href="https://docs.rs/tokio_codec"><code>tokio_util</code></a>.
Il permettent de lier l'utilisation de zone mémoire tampon avec l'encodage et le décodage de
messages. Le module expose un codec client, qui encode des requêtes et décode des réponses ainsi
qu'un codec serveur qui encode les réponses et décode les requètes.</p>
<p>L'interet d'exposer ces codec est de pouvoir utiliser la structure <code>tokio_util::codec::Framed</code>
exposé par la même libraire. La structure permet de créer un stream et un &quot;sink&quot; depuis un codec
(<code>Encoder + Decoder</code>) et une structure pouvant être lu/écrite de manière asynchrone
(<code>AsyncRead + AsyncWrite</code>). Le stream renvois ainsi les objets décodés et le &quot;sink&quot; permet d'envoyer
des objets qui seront encodés puis envoyés sur la connection.</p>
<h2><a class="header" href="#marché" id="marché">Marché</a></h2>
<p>Le marché est composé de plusieurs éléments. La structure principale qui sert de pointeur vers un
état partagé qui comprend une liste des coeurs du marché et un accès au routeur d'ordres. Tous les
coeurs ont également un pointeur vers un une structure partagé contenant le compte de chaque titres
ainsi qu'un accès au multicast.</p>
<p>Le but de cette structure est de servire d'interface partagé entre tous les clients pour envoyer des
ordres en contrepartie d'un future sur le résultat de cet ordre.</p>
<h3><a class="header" href="#routeur-et-coeurs-du-marché" id="routeur-et-coeurs-du-marché">Routeur et coeurs du marché</a></h3>
<p>Le router d'ordre est un structure faisant part du marché son but est d'envoyer les ordres sur les
différents coeurs. Les stratégies de routage des ordres peuvent être plus ou moins complexe. En
effet, le but des coeurs est d'éxécuter des ordres cependant on pourrait se retrouver dans une
situation ou un coeur recoit tous les ordres tandis que les autres ne font rien gachant ainsi du
temps de processeur. Par exemple, on pourrait imaginer une stratégie ou les ordres sont triés et en
fonction des titres visés sont envoyé sur un coeurs différent. Dans le cadre de ce projet le router
est plutot basique et agit comme une roue distribuant tour à tour à chaque coeur. Les points de
sortis des router implémente égalment le <em>trait</em> <code>futures::stream::Stream</code> de manière à ce que les
coeurs ne soient actifs que lorsque des ordres arrivent (et ainsi les notifiants).</p>
<p>Le coeur du marché est lancé sur un processus différent, il s'agit d'une structure asynchrone qui
attend les ordres du router. Une fois l'ordre reçu il tente attend de pouvoir avoir un accès
exclusifs (via un <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a>) aux quantités actuelles
de l'animateur de marché. Une fois les quantités acquises il calcule le score pour les anciennes et
le score pour les nouvelles après avoir éxécuté tous les ordres determinant le prix de la
transaction. Une fois le verrous des quantités levé il tente de partager les nouvelles quantités,
cette action échouera si les quantités ont été partagé trop récemment.</p>
<h3><a class="header" href="#titres" id="titres">Titres</a></h3>
<p>Le fichier <code>src/market/securities.rs</code> permet d'éditer les titres avant la compilation et contient
également des fonctions y facilitant l'accès. Le fichier définit également un autre type
<code>Securities</code> dont la description est du texte statique car il est, pour le moment, impossible de
créer statiquement (comprendre lors de la compilation) un pointeur de texte <code>String</code> requis par
prost pour les entrées type string en protobuf.</p>
<pre><code class="language-rust ignore">const SECURITIES: &amp;'static [Security] = &amp;[
    Security {
        security_id: 0,
        description: &quot;first security&quot;,
    },
    Security {
        security_id: 1,
        description: &quot;second security&quot;,
    },
    Security {
        security_id: 2,
        description: &quot;third security&quot;,
    },
];
</code></pre>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>
<p>Pour conclure nous avons pu voir l'utilisation des règles de score comme animateur de marché
automatisés permettant ainsi de regler le problème de liquidité des marchés fins. Nous avons
également parlé de l'experience du marché de l'information du centre Gates Hillman en tirant des
conclusions sur l'utilisation d'une règle de score de marché logarithmique et les incitaions qu'elle
a crée chez les agents. Cette base théorique à permis de construire un marché totalement asynchrone
en language Rust.</p>
<p>Une suite à ce projet serait d'experimenter le serveur dans un cadre pratique avec des agents réels.</p>
<h1><a class="header" href="#documentation" id="documentation">Documentation</a></h1>
<ul>
<li>A Practical Liquidity-Sensitive Automated Market Maker - A. Othman, T. Sandholm, D. Pennock, D. Reeves (2010)</li>
<li>Automated Market Making: Theory and Practice - A. Othman (2012)</li>
<li>Betting on Permutations - Y. Chen, D. Pennock (2005)</li>
<li>Complexity of Market Making - Y.Chen, D. Pennock (2008)</li>
<li>Computational Aspects of Prediction Markets - D. Pennock, R. Sami</li>
<li>Gates Hillman Prediction Market - A. Othman, T. Sandholm (2010)</li>
<li>Logarithmic Market Scoring Rules for Modular Combinatorial Information Aggregation - R. Hanson (2002)</li>
<li>Market vs Pool - Y. Chen, D. Pennock (2005)</li>
<li>Multi-outcome and Multidimensional Market Scoring Rules - L. Fortnow, R. Sami (2012)</li>
<li>Prediction Markets: Economics, Computation, and Mechanism Design - Y. Chen (2007)</li>
<li>The Hidden Beauty of the Quadratic Market Scoring Rule: A Uniform Liquidity Market Maker, with Variations - M. Abramowicz (2007)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
